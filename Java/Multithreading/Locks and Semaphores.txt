synchronized lock is used to put on monitor lock , i.e on the obj . 

if 2 different obj works on it , it can work independently.
public class SharedResource{
boolean isAvailable=false;
public synchronized void producer(){

  try{
    System.out.println("lock acquired by : "+Thread.currentThread().getName());
    isAvailable=true;
    Thread.sleep(2000);
  }catch(Exception e){
    //  handle exception
  }
}
}

main(){
  SharedResource resource1= new SharedResource();
  SharedResource resource2= new SharedResource();

  Thread th1= (()->{
   resource1.producer();
  });

  Thread th1= (()->{
   resource2.producer();
  });

  th1.start();
  th2.start();
}

// here thread 1 will put a lock , and after completion it will release it
// here thread 2 will put a lock , and after completion it will release it
// here both the thread will work independently, as monitor lock is placed on object.


--------- To put a lock on a block of code , irrespective of the obj.

custom locks
-- ReentrantLock: The ReentrantLock is a lock that allows the thread that holds the lock to re-enter the lock multiple times without causing a deadlock.independent of the object, but dependent on the lock obj passed

-- ReadWriteLock: Shared lock , multiple thread can have shared lock , only read.but for exclusive lock, it should be independent of any previous lock, only 1 thread can have exclusive lock at a single tiime
- ReadLock: more than 1 thread can acquire the read lock.
- WriteLock:  only 1 thread can acquire the write lock.
-- StampedLock- Read/Write  & optimistic Read
Key Points
Optimistic Reading: The optimistic read allows multiple threads to read data concurrently without blocking each other, improving performance in read-heavy workloads.
Validation: Validation ensures that the data read optimistically is consistent. If the data has been modified by a write operation, the reader thread falls back to a traditional read lock to get consistent data.
Rollback: In the context of optimistic locking, "rollback" refers to discarding the optimistically read data if the validation fails and reading the data again with proper locking.
Optimistic locking is efficient for scenarios where conflicts are rare and the cost of occasional retries (falling back to a read lock) is outweighed by the performance benefits of allowing concurrent reads.
-- SemaphoreLock
